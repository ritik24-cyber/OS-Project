/*
 * =====================================================
 * Operating Systems Mini Project
 * FCFS CPU Scheduling & First-Fit Memory Allocation
 * =====================================================
 * Name: Ritik Raj
 * USN: 1RF24IS093
 * =====================================================
 */

#include <stdio.h>
#include <stdlib.h>

// Structure to hold process information for FCFS
struct Process {
    int pid;          // Process ID
    int arrival;      // Arrival Time
    int burst;        // Burst Time
    int waiting;      // Waiting Time
    int turnaround;   // Turnaround Time
    int completion;   // Completion Time
};

// Structure for memory blocks in First-Fit
struct MemoryBlock {
    int blockId;      // Block ID
    int size;         // Block Size
    int allocated;    // 0 = Free, Process ID if allocated
};

// Function prototypes
void fcfsScheduling();
void firstFitAllocation();
void displayMenu();
void printGanttChart(struct Process processes[], int n);
void clearInputBuffer();

/*
 * Main function - Entry point of the program
 * Displays menu and handles user choice
 */
int main() {
    int choice;
    
    printf("\n");
    printf("╔══════════════════════════════════════════════════════════╗\n");
    printf("║     OPERATING SYSTEMS MINI PROJECT                       ║\n");
    printf("║     FCFS Scheduling & First-Fit Memory Allocation        ║\n");
    printf("║     By: RITIK RAJ (1RF24IS093)                          ║\n");
    printf("╚══════════════════════════════════════════════════════════╝\n");
    
    do {
        displayMenu();
        printf("\nEnter your choice: ");
        
        if (scanf("%d", &choice) != 1) {
            printf("\n[ERROR] Invalid input! Please enter a number.\n");
            clearInputBuffer();
            continue;
        }
        
        switch(choice) {
            case 1:
                fcfsScheduling();
                break;
            case 2:
                firstFitAllocation();
                break;
            case 3:
                printf("\n╔═══════════════════════════════════════╗\n");
                printf("║  Thank you for using this program!    ║\n");
                printf("║  Exiting...                           ║\n");
                printf("╚═══════════════════════════════════════╝\n\n");
                break;
            default:
                printf("\n[ERROR] Invalid choice! Please select 1, 2, or 3.\n");
        }
    } while(choice != 3);
    
    return 0;
}

/*
 * Display the main menu options
 */
void displayMenu() {
    printf("\n┌─────────────────────────────────────┐\n");
    printf("│           MAIN MENU                 │\n");
    printf("├─────────────────────────────────────┤\n");
    printf("│  1. FCFS CPU Scheduling             │\n");
    printf("│  2. First-Fit Memory Allocation     │\n");
    printf("│  3. Exit                            │\n");
    printf("└─────────────────────────────────────┘\n");
}

/*
 * Clear the input buffer to prevent invalid input issues
 */
void clearInputBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

/*
 * FCFS (First Come First Serve) CPU Scheduling Algorithm
 * 
 * Algorithm Steps:
 * 1. Accept number of processes and their arrival/burst times
 * 2. Sort processes by arrival time (already in order for FCFS)
 * 3. Calculate completion time for each process
 * 4. Calculate turnaround time = completion time - arrival time
 * 5. Calculate waiting time = turnaround time - burst time
 * 6. Display Gantt chart and results table
 */
void fcfsScheduling() {
    int n, i;
    float totalWaiting = 0, totalTurnaround = 0;
    
    printf("\n╔═══════════════════════════════════════════════════════════╗\n");
    printf("║         FCFS (First Come First Serve) SCHEDULING          ║\n");
    printf("╚═══════════════════════════════════════════════════════════╝\n");
    
    // Get number of processes
    printf("\nEnter the number of processes: ");
    if (scanf("%d", &n) != 1 || n <= 0) {
        printf("[ERROR] Invalid number of processes!\n");
        clearInputBuffer();
        return;
    }
    
    // Dynamically allocate memory for processes
    struct Process *processes = (struct Process *)malloc(n * sizeof(struct Process));
    if (processes == NULL) {
        printf("[ERROR] Memory allocation failed!\n");
        return;
    }
    
    // Input process details
    printf("\n--- Enter Process Details ---\n");
    for (i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("\nProcess P%d:\n", i + 1);
        
        printf("  Arrival Time: ");
        if (scanf("%d", &processes[i].arrival) != 1 || processes[i].arrival < 0) {
            printf("[ERROR] Invalid arrival time!\n");
            free(processes);
            clearInputBuffer();
            return;
        }
        
        printf("  Burst Time: ");
        if (scanf("%d", &processes[i].burst) != 1 || processes[i].burst <= 0) {
            printf("[ERROR] Invalid burst time!\n");
            free(processes);
            clearInputBuffer();
            return;
        }
    }
    
    // Sort processes by arrival time using bubble sort
    for (i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (processes[j].arrival > processes[j + 1].arrival) {
                struct Process temp = processes[j];
                processes[j] = processes[j + 1];
                processes[j + 1] = temp;
            }
        }
    }
    
    // Calculate completion, turnaround, and waiting times
    int currentTime = 0;
    
    for (i = 0; i < n; i++) {
        // If CPU is idle, move time to process arrival
        if (currentTime < processes[i].arrival) {
            currentTime = processes[i].arrival;
        }
        
        // Process starts execution
        currentTime += processes[i].burst;
        processes[i].completion = currentTime;
        
        // Turnaround Time = Completion Time - Arrival Time
        processes[i].turnaround = processes[i].completion - processes[i].arrival;
        
        // Waiting Time = Turnaround Time - Burst Time
        processes[i].waiting = processes[i].turnaround - processes[i].burst;
        
        // Accumulate totals for averages
        totalWaiting += processes[i].waiting;
        totalTurnaround += processes[i].turnaround;
    }
    
    // Display Gantt Chart
    printGanttChart(processes, n);
    
    // Display results table
    printf("\n┌─────────────────────────────────────────────────────────────────────────┐\n");
    printf("│                          SCHEDULING TABLE                               │\n");
    printf("├─────────┬─────────────┬────────────┬────────────────┬───────────┬───────┤\n");
    printf("│ Process │ Arrival (AT)│ Burst (BT) │ Completion (CT)│ TAT (CT-AT)│ WT   │\n");
    printf("├─────────┼─────────────┼────────────┼────────────────┼───────────┼───────┤\n");
    
    for (i = 0; i < n; i++) {
        printf("│   P%-4d │     %-7d │    %-7d │      %-9d │    %-6d │ %-5d│\n",
               processes[i].pid,
               processes[i].arrival,
               processes[i].burst,
               processes[i].completion,
               processes[i].turnaround,
               processes[i].waiting);
    }
    
    printf("└─────────┴─────────────┴────────────┴────────────────┴───────────┴───────┘\n");
    
    // Display averages
    printf("\n╔═══════════════════════════════════════════════════════╗\n");
    printf("║  Average Waiting Time     : %.2f time units           ║\n", totalWaiting / n);
    printf("║  Average Turnaround Time  : %.2f time units           ║\n", totalTurnaround / n);
    printf("╚═══════════════════════════════════════════════════════╝\n");
    
    // Free allocated memory
    free(processes);
}

/*
 * Print Gantt Chart for FCFS scheduling
 * Visualizes the order of process execution
 */
void printGanttChart(struct Process processes[], int n) {
    int i;
    
    printf("\n┌───────────────────────────────────────────────────────────┐\n");
    printf("│                      GANTT CHART                          │\n");
    printf("└───────────────────────────────────────────────────────────┘\n\n");
    
    // Print top border
    printf(" ");
    for (i = 0; i < n; i++) {
        for (int j = 0; j < processes[i].burst; j++)
            printf("──");
        printf(" ");
    }
    printf("\n│");
    
    // Print process IDs
    for (i = 0; i < n; i++) {
        for (int j = 0; j < processes[i].burst - 1; j++)
            printf(" ");
        printf("P%d", processes[i].pid);
        for (int j = 0; j < processes[i].burst - 1; j++)
            printf(" ");
        printf("│");
    }
    printf("\n ");
    
    // Print bottom border
    for (i = 0; i < n; i++) {
        for (int j = 0; j < processes[i].burst; j++)
            printf("──");
        printf(" ");
    }
    printf("\n");
    
    // Print time markers
    int currentTime = 0;
    if (processes[0].arrival > 0) {
        currentTime = processes[0].arrival;
    }
    printf("0");
    
    for (i = 0; i < n; i++) {
        for (int j = 0; j < processes[i].burst; j++)
            printf("  ");
        currentTime += processes[i].burst;
        printf("%d", currentTime);
    }
    printf("\n");
}

/*
 * First-Fit Memory Allocation Algorithm
 * 
 * Algorithm Steps:
 * 1. Accept number of memory blocks and their sizes
 * 2. Accept number of processes and their memory requirements
 * 3. For each process, find the FIRST block that fits
 * 4. Allocate memory and update block status
 * 5. Calculate internal fragmentation and display results
 */
void firstFitAllocation() {
    int numBlocks, numProcesses, i, j;
    int totalMemory = 0, allocatedMemory = 0;
    
    printf("\n╔═══════════════════════════════════════════════════════════╗\n");
    printf("║           FIRST-FIT MEMORY ALLOCATION                     ║\n");
    printf("╚═══════════════════════════════════════════════════════════╝\n");
    
    // Get number of memory blocks
    printf("\nEnter the number of memory blocks: ");
    if (scanf("%d", &numBlocks) != 1 || numBlocks <= 0) {
        printf("[ERROR] Invalid number of blocks!\n");
        clearInputBuffer();
        return;
    }
    
    // Allocate memory for blocks
    struct MemoryBlock *blocks = (struct MemoryBlock *)malloc(numBlocks * sizeof(struct MemoryBlock));
    int *originalSize = (int *)malloc(numBlocks * sizeof(int));
    
    if (blocks == NULL || originalSize == NULL) {
        printf("[ERROR] Memory allocation failed!\n");
        return;
    }
    
    // Input block sizes
    printf("\n--- Enter Memory Block Sizes ---\n");
    for (i = 0; i < numBlocks; i++) {
        blocks[i].blockId = i + 1;
        blocks[i].allocated = 0;  // Initially free
        
        printf("Block %d size (KB): ", i + 1);
        if (scanf("%d", &blocks[i].size) != 1 || blocks[i].size <= 0) {
            printf("[ERROR] Invalid block size!\n");
            free(blocks);
            free(originalSize);
            clearInputBuffer();
            return;
        }
        originalSize[i] = blocks[i].size;
        totalMemory += blocks[i].size;
    }
    
    // Get number of processes
    printf("\nEnter the number of processes: ");
    if (scanf("%d", &numProcesses) != 1 || numProcesses <= 0) {
        printf("[ERROR] Invalid number of processes!\n");
        free(blocks);
        free(originalSize);
        clearInputBuffer();
        return;
    }
    
    // Allocate arrays for process information
    int *processSize = (int *)malloc(numProcesses * sizeof(int));
    int *allocation = (int *)malloc(numProcesses * sizeof(int));
    
    if (processSize == NULL || allocation == NULL) {
        printf("[ERROR] Memory allocation failed!\n");
        free(blocks);
        free(originalSize);
        return;
    }
    
    // Initialize allocation array (-1 means not allocated)
    for (i = 0; i < numProcesses; i++) {
        allocation[i] = -1;
    }
    
    // Input process memory requirements
    printf("\n--- Enter Process Memory Requirements ---\n");
    for (i = 0; i < numProcesses; i++) {
        printf("Process P%d size (KB): ", i + 1);
        if (scanf("%d", &processSize[i]) != 1 || processSize[i] <= 0) {
            printf("[ERROR] Invalid process size!\n");
            free(blocks);
            free(originalSize);
            free(processSize);
            free(allocation);
            clearInputBuffer();
            return;
        }
    }
    
    // First-Fit Allocation Algorithm
    printf("\n--- Performing First-Fit Allocation ---\n");
    
    for (i = 0; i < numProcesses; i++) {
        // Find the FIRST block that can accommodate this process
        for (j = 0; j < numBlocks; j++) {
            if (blocks[j].size >= processSize[i]) {
                // Allocate this block to the process
                allocation[i] = j;
                blocks[j].size -= processSize[i];  // Reduce available size
                blocks[j].allocated = i + 1;       // Mark as allocated
                allocatedMemory += processSize[i];
                
                printf("  Process P%d (size: %d KB) -> Block %d\n", 
                       i + 1, processSize[i], j + 1);
                break;  // Move to next process (First-Fit: stop at first match)
            }
        }
        
        if (allocation[i] == -1) {
            printf("  Process P%d (size: %d KB) -> NOT ALLOCATED (no suitable block)\n",
                   i + 1, processSize[i]);
        }
    }
    
    // Display Memory Allocation Table
    printf("\n┌────────────────────────────────────────────────────────────────────┐\n");
    printf("│                    MEMORY ALLOCATION TABLE                         │\n");
    printf("├───────────┬──────────────────┬─────────────────────────────────────┤\n");
    printf("│  Process  │  Memory Required │        Allocated Block              │\n");
    printf("├───────────┼──────────────────┼─────────────────────────────────────┤\n");
    
    for (i = 0; i < numProcesses; i++) {
        if (allocation[i] != -1) {
            printf("│    P%-5d │      %-10d │  Block %-5d (Original: %d KB)     │\n",
                   i + 1, processSize[i], allocation[i] + 1, originalSize[allocation[i]]);
        } else {
            printf("│    P%-5d │      %-10d │  NOT ALLOCATED                     │\n",
                   i + 1, processSize[i]);
        }
    }
    printf("└───────────┴──────────────────┴─────────────────────────────────────┘\n");
    
    // Display Memory Block Status
    printf("\n┌────────────────────────────────────────────────────────────┐\n");
    printf("│                 MEMORY BLOCK STATUS                        │\n");
    printf("├──────────┬──────────────┬───────────────┬──────────────────┤\n");
    printf("│  Block   │ Original Size│ Remaining Size│    Status        │\n");
    printf("├──────────┼──────────────┼───────────────┼──────────────────┤\n");
    
    int totalFragmentation = 0;
    for (i = 0; i < numBlocks; i++) {
        char status[20];
        if (blocks[i].allocated > 0) {
            sprintf(status, "Allocated (P%d)", blocks[i].allocated);
            totalFragmentation += blocks[i].size;  // Internal fragmentation
        } else {
            sprintf(status, "Free");
            totalFragmentation += blocks[i].size;  // External fragmentation
        }
        
        printf("│  Block %-2d│    %-9d │     %-9d │ %-16s │\n",
               i + 1, originalSize[i], blocks[i].size, status);
    }
    printf("└──────────┴──────────────┴───────────────┴──────────────────┘\n");
    
    // Calculate and display fragmentation
    int externalFrag = 0;
    for (i = 0; i < numBlocks; i++) {
        externalFrag += blocks[i].size;
    }
    
    printf("\n╔════════════════════════════════════════════════════════════╗\n");
    printf("║                  MEMORY STATISTICS                         ║\n");
    printf("╠════════════════════════════════════════════════════════════╣\n");
    printf("║  Total Memory Available    : %-6d KB                      ║\n", totalMemory);
    printf("║  Total Memory Allocated    : %-6d KB                      ║\n", allocatedMemory);
    printf("║  External Fragmentation    : %-6d KB                      ║\n", externalFrag);
    printf("║  Memory Utilization        : %.2f%%                        ║\n", 
           (float)allocatedMemory / totalMemory * 100);
    printf("╚════════════════════════════════════════════════════════════╝\n");
    
    // Visual Memory Map
    printf("\n┌────────────────────────────────────────────────────────────┐\n");
    printf("│                    VISUAL MEMORY MAP                       │\n");
    printf("└────────────────────────────────────────────────────────────┘\n\n");
    
    for (i = 0; i < numBlocks; i++) {
        printf("Block %d [", i + 1);
        int filled = (originalSize[i] - blocks[i].size) * 20 / originalSize[i];
        int empty = 20 - filled;
        
        for (j = 0; j < filled; j++) printf("█");
        for (j = 0; j < empty; j++) printf("░");
        
        printf("] %d/%d KB", originalSize[i] - blocks[i].size, originalSize[i]);
        if (blocks[i].allocated > 0) {
            printf(" (P%d)", blocks[i].allocated);
        }
        printf("\n");
    }
    
    // Free allocated memory
    free(blocks);
    free(originalSize);
    free(processSize);
    free(allocation);
}

/*
 * End of Program
 * Thank you for using this Operating Systems Mini Project!
 */
